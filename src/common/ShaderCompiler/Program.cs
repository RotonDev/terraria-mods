using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Newtonsoft.Json;

namespace Tomat.DirectX.ShaderCompiler;

internal static class Program
{
    private sealed class ShaderMetadata
    {
        [JsonProperty("samplers")]
        public Dictionary<string, string> Samplers { get; set; } = [];

        [JsonProperty("uniforms")]
        public Dictionary<string, string> Uniforms { get; set; } = [];

        [JsonProperty("profile")]
        public string Profile { get; set; } = "";

        [JsonProperty("input")]
        public string Input { get; set; } = "";

        [JsonProperty("output")]
        public string Output { get; set; } = "";

        [JsonProperty("uniformOutput")]
        public string UniformOutput { get; set; } = "";
    }

    public static void Main(string[] args)
    {
        if (args.Length == 0 || args is ["--generate-uniforms"])
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("  shaderc <options> <files>");
            return;
        }

        CompileShaders(args[1..], args[0] == "--generate-uniforms");
    }

    private static void CompileShaders(string[] files, bool justGenerateUniforms)
    {
        foreach (var file in files)
        {
            if (!File.Exists(file))
            {
                Console.Error.WriteLine($"File {file} not found");
                continue;
            }

            var basePath = Path.GetFullPath(Path.GetDirectoryName(file) ?? "");

            ShaderMetadata? shaderMetadata;
            try
            {
                shaderMetadata = JsonConvert.DeserializeObject<ShaderMetadata>(File.ReadAllText(file));

                if (shaderMetadata is null)
                {
                    Console.Error.WriteLine("Failed to parse shader metadata file: " + file);
                    return;
                }
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error reading shader metadata: " + e);
                return;
            }

            GenerateUniforms(shaderMetadata, basePath);

            if (justGenerateUniforms)
            {
                return;
            }

            // CompileShader(shaderMetadata, basePath);
        }
    }

    private static void GenerateUniforms(ShaderMetadata metadata, string basePath)
    {
        var uniformOutputPath = Path.GetFullPath(metadata.UniformOutput, basePath);

        if (File.Exists(uniformOutputPath))
        {
            File.Delete(uniformOutputPath);
        }

        Directory.CreateDirectory(Path.GetDirectoryName(uniformOutputPath)!);
        var sb = new StringBuilder();
        {
            sb.AppendLine("// -----------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by a tool.");
            sb.AppendLine("//");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if the");
            sb.AppendLine("//     code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("// -----------------------------------------------------------------------------");
            sb.AppendLine();

            sb.AppendLine("// begin SAMPLERS");
            foreach (var (name, register) in metadata.Samplers)
            {
                sb.AppendLine($"sampler {name} : register({register});");
            }
            sb.AppendLine("// end SAMPLERS");
            sb.AppendLine();
            sb.AppendLine("// begin UNIFORMS");
            foreach (var (name, type) in metadata.Uniforms)
            {
                sb.AppendLine($"{type} {name};");
            }
            sb.AppendLine("// end UNIFORMS");
        }
        File.WriteAllText(uniformOutputPath, sb.ToString());
    }
}