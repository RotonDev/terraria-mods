using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

using Newtonsoft.Json;

namespace Tomat.DirectX.ShaderCompiler;

internal static class Program
{
    private sealed class ShaderMetadata
    {
        [JsonProperty("samplers")]
        public Dictionary<string, string> Samplers { get; set; } = [];

        [JsonProperty("uniforms")]
        public Dictionary<string, string> Uniforms { get; set; } = [];

        [JsonProperty("passes")]
        public Dictionary<string, Dictionary<string, string>> Passes { get; set; } = [];

        [JsonProperty("profile")]
        public string Profile { get; set; } = "";
    }

    private static string baseDirectory = null!;

    public static void Main(string[] args)
    {
        if (args.Length == 0 || args is ["--generate-uniforms"])
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("  shaderc <options> <files>");
            return;
        }

        baseDirectory = Path.GetDirectoryName(Path.GetFullPath(Environment.ProcessPath!))!;

        try
        {
            if (args[0] == "--generate-uniforms")
            {
                CompileShaders(args[1..], true);
            }
            else
            {
                CompileShaders(args, false);
            }
        }
        catch (Exception e)
        {
            Console.Error.WriteLine("FAILED TO COMPILE SHADERS: " + e);
        }
    }

    private static void CompileShaders(string[] files, bool justGenerateUniforms)
    {
        foreach (var file in files)
        {
            if (!File.Exists(file))
            {
                Console.Error.WriteLine($"File {file} not found");
                Environment.ExitCode = 1;
                continue;
            }

            var filePath = Path.GetFileNameWithoutExtension(Path.GetFullPath(file));
            var basePath = Path.GetFullPath(Path.GetDirectoryName(file) ?? "");

            ShaderMetadata? shaderMetadata;
            try
            {
                shaderMetadata = JsonConvert.DeserializeObject<ShaderMetadata>(File.ReadAllText(file));

                if (shaderMetadata is null)
                {
                    Console.Error.WriteLine("Failed to parse shader metadata file: " + file);
                    Environment.ExitCode = 1;
                    continue;
                }
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error reading shader metadata: " + e);
                Environment.ExitCode = 1;
                continue;
            }

            GenerateUniforms(shaderMetadata, basePath, filePath);

            if (justGenerateUniforms)
            {
                continue;
            }

            CompileShader(shaderMetadata, basePath, filePath);
        }
    }

    private static void GenerateUniforms(ShaderMetadata metadata, string basePath, string filePathWithoutExtension)
    {
        var uniformOutputPath = Path.GetFullPath(filePathWithoutExtension + ".uniforms.hlsl", basePath);

        if (File.Exists(uniformOutputPath))
        {
            File.Delete(uniformOutputPath);
        }

        Directory.CreateDirectory(Path.GetDirectoryName(uniformOutputPath)!);
        var sb = new StringBuilder();
        {
            sb.AppendLine("// -----------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by a tool.");
            sb.AppendLine("//");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if the");
            sb.AppendLine("//     code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("// -----------------------------------------------------------------------------");
            sb.AppendLine();

            sb.AppendLine("#ifndef TECHNIQUES");
            sb.AppendLine("// begin SAMPLERS");
            foreach (var (name, register) in metadata.Samplers)
            {
                sb.AppendLine($"sampler {name} : register({register});");
            }
            sb.AppendLine("// end SAMPLERS");
            sb.AppendLine();
            sb.AppendLine("// begin UNIFORMS");
            foreach (var (name, type) in metadata.Uniforms)
            {
                sb.AppendLine($"{type} {name};");
            }
            sb.AppendLine("// end UNIFORMS");
            sb.AppendLine("#endif // TECHNIQUES");
            sb.AppendLine();
            sb.AppendLine("// begin PASSES");
            sb.AppendLine("#ifdef FX");
            sb.AppendLine("#ifdef TECHNIQUES");
            sb.AppendLine("technique Technique1");
            sb.AppendLine("{");
            foreach (var (passName, shaders) in metadata.Passes)
            {
                sb.AppendLine($"    pass {passName}");
                sb.AppendLine("    {");
                foreach (var (stage, expression) in shaders)
                {
                    sb.AppendLine($"        {stage} = compile {expression}();");
                }
                sb.AppendLine("    }");
            }
            sb.AppendLine("}");
            sb.AppendLine("#endif // TECHNIQUES");
            sb.AppendLine("#endif // FX");
            sb.AppendLine("// end PASSES");
        }
        File.WriteAllText(uniformOutputPath, sb.ToString());
    }

    private static void CompileShader(ShaderMetadata metadata, string basePath, string filePathWithoutExtension)
    {
        var fxcExe = Path.Combine(baseDirectory, "native", "fxc.exe");
        
        if (!File.Exists(fxcExe))
        {
            Console.Error.WriteLine("Couldn't find fxc.exe");
            Environment.ExitCode = 1;
            return;
        }

        // Leave out special cases like ".effect.json".
        var realFileName = Path.GetFileName(filePathWithoutExtension).Split('.').First();

        var hlslFile  = Path.Combine(basePath, realFileName + ".hlsl");
        var fxcOutput = Path.Combine(basePath, realFileName + ".fxc");
        var isLinux   = Environment.OSVersion.Platform == PlatformID.Unix;
        string fxcExePath = "";
        if (isLinux) {
            try
            {
                var otherProcess = new Process();
                var processStartInfo = new ProcessStartInfo()
                {
                    WindowStyle = ProcessWindowStyle.Hidden,
                    FileName = $"/bin/bash",
                    Arguments = $"-c \"command -v wine\"",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false
                };
                otherProcess.StartInfo = processStartInfo;
                otherProcess.Start();

                String error = otherProcess.StandardError.ReadToEnd();
                String output = otherProcess.StandardOutput.ReadToEnd();

                if (!string.IsNullOrEmpty(error))
                {
                    Console.Error.WriteLine("Error: " + error);
                    Environment.ExitCode = 1;
                    return;
                }
                if (!string.IsNullOrEmpty(output))
                {
                    fxcExePath = fxcExe;
                    fxcExe = output.Trim();
                }
                else
                {
                    Console.Error.WriteLine("Error: wine not found. maybe try installing it from your package manager?");
                    Environment.ExitCode = 1;
                    return;
                }
                
            }
            catch(Exception ex)
            {
                throw;
            }
        }
        var pInfo = new ProcessStartInfo
        {
            FileName               = fxcExe,
            Arguments              = $"{fxcExePath} /T {metadata.Profile} \"{hlslFile}\" /Fo \"{fxcOutput}\" /D FX=1 /O3 /Op",
            RedirectStandardOutput = true,
            RedirectStandardError  = true,
            UseShellExecute        = false,
            CreateNoWindow         = true,
        };

        using var process = new Process();
        process.StartInfo          =  pInfo;
        process.OutputDataReceived += (_, e) => Console.WriteLine(e.Data);
        process.ErrorDataReceived  += (_, e) => Console.Error.WriteLine(e.Data);

        process.Start();
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();
        process.WaitForExit();

        if (process.ExitCode == 0)
        {
            return;
        }

        Console.Error.WriteLine($"fxc.exe exited with code {process.ExitCode}");
        Environment.ExitCode = process.ExitCode;
    }
}